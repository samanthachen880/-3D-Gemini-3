<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 粒子线稿交互系统</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', sans-serif; }
        
        /* UI 容器 */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            pointer-events: none; /* 让鼠标事件穿透到 Canvas */
            display: flex;
            flex-direction: column;
            gap: 15px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            width: 280px;
        }

        /* 交互元素启用点击 */
        #ui-container > * { pointer-events: auto; }

        h1 { font-size: 16px; margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 2px; color: #aaa; }

        .control-group { margin-bottom: 10px; }
        label { display: block; font-size: 12px; margin-bottom: 5px; color: #888; }
        
        input[type="file"] {
            display: none;
        }

        .custom-file-upload {
            border: 1px dashed #555;
            display: inline-block;
            padding: 10px 20px;
            cursor: pointer;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
            border-radius: 6px;
            transition: 0.3s;
            font-size: 13px;
        }
        .custom-file-upload:hover { background: rgba(255,255,255,0.1); border-color: #fff; }

        input[type="color"] {
            width: 100%;
            height: 35px;
            border: none;
            background: none;
            cursor: pointer;
        }

        button {
            background: #ffffff;
            color: #000;
            border: none;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            width: 100%;
        }
        button:hover { background: #ddd; }

        #camera-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1); /* 镜像 */
            border-radius: 8px;
            border: 2px solid rgba(255,255,255,0.2);
            z-index: 90;
            object-fit: cover;
            opacity: 0.7;
        }

        #status {
            font-size: 12px;
            color: #0f0;
            margin-top: 5px;
        }
        
        .loading { color: #f90 !important; }

        /* 隐藏 MediaPipe 需要的 Video 元素 */
        .input_video { display: none; }
    </style>
    
    <!-- 引入 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 引入 MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-container">
        <h1>粒子线稿系统</h1>
        
        <div class="control-group">
            <label>1. 上传图片 (支持多选3张)</label>
            <label for="file-upload" class="custom-file-upload">
                点击上传图片
            </label>
            <input id="file-upload" type="file" accept="image/*" multiple />
            <div id="status">等待上传...</div>
        </div>

        <div class="control-group">
            <label>2. 粒子颜色</label>
            <input type="color" id="color-picker" value="#00ffff">
        </div>

        <div class="control-group">
            <button id="fullscreen-btn">全屏模式</button>
        </div>
        
        <div class="control-group">
            <label>操作说明:</label>
            <span style="font-size: 11px; color:#666; line-height: 1.4;">
                • 允许摄像头权限<br>
                • 捏合手指: 粒子聚集/缩小<br>
                • 张开手掌: 粒子扩散/放大<br>
                • 图片将自动轮播
            </span>
        </div>
    </div>

    <!-- 摄像头预览 -->
    <video id="camera-preview" autoplay playsinline muted></video>
    <!-- MediaPipe 实际使用的视频源 -->
    <video class="input_video"></video>

    <script>
        // ================= 配置与全局变量 =================
        let scene, camera, renderer, particles, geometry, material;
        let originalPositions = []; // 存储图像边缘的原始坐标
        let currentImageIndex = 0;
        let uploadedImages = []; // 存储处理后的 ImageData
        let handInteraction = {
            active: false,
            spread: 0, // 0 (closed) to 1 (open)
            centerX: 0,
            centerY: 0
        };
        const IMAGE_WIDTH = 200; // 降低分辨率以提高粒子性能
        const IMAGE_HEIGHT = 200;
        const PARTICLE_SIZE = 1.5;
        
        // ================= 1. Three.js 初始化 =================
        function initThree() {
            scene = new THREE.Scene();
            // 稍微带点雾气增加深度感
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 300;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 初始化一个空的粒子系统
            geometry = new THREE.BufferGeometry();
            // 初始放一些不可见的点，防止报错
            const positions = new Float32Array(3);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            material = new THREE.PointsMaterial({
                color: 0x00ffff,
                size: PARTICLE_SIZE,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ================= 2. 图像处理 (边缘检测转粒子) =================
        
        // 将图片转换为粒子坐标数组 (Edge Detection)
        function processImageToParticles(img) {
            const canvas = document.createElement('canvas');
            canvas.width = IMAGE_WIDTH;
            canvas.height = IMAGE_HEIGHT;
            const ctx = canvas.getContext('2d');
            
            // 保持比例绘制
            const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
            const x = (canvas.width / 2) - (img.width / 2) * scale;
            const y = (canvas.height / 2) - (img.height / 2) * scale;
            ctx.drawImage(img, x, y, img.width * scale, img.height * scale);

            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            const positions = [];

            // 简单的边缘检测算法
            // 遍历像素，对比当前像素与右侧、下侧像素的亮度差
            const threshold = 15; // 边缘检测阈值，越小线条越多
            
            function getBrightness(i) {
                return 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
            }

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    
                    // 边界检查
                    if (x < canvas.width - 1 && y < canvas.height - 1) {
                        const current = getBrightness(i);
                        const right = getBrightness(i + 4);
                        const bottom = getBrightness(i + canvas.width * 4);

                        // 如果与邻居的亮度差大于阈值，则视为边缘
                        if (Math.abs(current - right) > threshold || Math.abs(current - bottom) > threshold) {
                            // 将 2D 坐标映射到 3D 空间，居中
                            const pX = x - canvas.width / 2;
                            const pY = -(y - canvas.height / 2); // Y轴反转
                            const pZ = 0;
                            positions.push(pX, pY, pZ);
                        }
                    }
                }
            }
            return new Float32Array(positions);
        }

        function updateParticles(newPositions) {
            originalPositions = newPositions;
            // 更新几何体
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(newPositions), 3));
            geometry.attributes.position.needsUpdate = true;
            
            // 重新让粒子有些随机分布，为了之后的聚合动画效果
            // 这里我们直接设置当前位置为目标位置，但在 animate 中会加入扰动
        }

        // 处理文件上传
        document.getElementById('file-upload').addEventListener('change', function(e) {
            const files = e.target.files;
            if (files.length === 0) return;

            const status = document.getElementById('status');
            status.textContent = `处理 ${files.length} 张图片中...`;
            status.className = 'loading';

            uploadedImages = []; // 清空旧的
            let loadedCount = 0;

            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        const posData = processImageToParticles(img);
                        uploadedImages.push(posData);
                        loadedCount++;
                        
                        if (loadedCount === files.length) {
                            status.textContent = "就绪! (捏合手指控制)";
                            status.className = '';
                            currentImageIndex = 0;
                            updateParticles(uploadedImages[0]);
                            
                            // 如果有多张图，开启自动轮播
                            if (uploadedImages.length > 1) {
                                startSlideshow();
                            }
                        }
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });
        });

        // 简单的轮播逻辑
        let slideshowInterval;
        function startSlideshow() {
            if (slideshowInterval) clearInterval(slideshowInterval);
            slideshowInterval = setInterval(() => {
                if (uploadedImages.length > 1) {
                    currentImageIndex = (currentImageIndex + 1) % uploadedImages.length;
                    updateParticles(uploadedImages[currentImageIndex]);
                }
            }, 5000); // 每5秒切换一次
        }

        // ================= 3. MediaPipe 手势识别 =================
        const videoElement = document.getElementsByClassName('input_video')[0];
        const previewElement = document.getElementById('camera-preview');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handInteraction.active = true;
                const landmarks = results.multiHandLandmarks[0];

                // 1. 计算手掌中心 (简单的平均值)
                // x轴需要镜像 (1 - x)
                let cx = (1 - landmarks[9].x) * window.innerWidth - window.innerWidth/2; 
                let cy = -(landmarks[9].y * window.innerHeight - window.innerHeight/2);
                
                // 平滑处理位置
                handInteraction.centerX += (cx - handInteraction.centerX) * 0.1;
                handInteraction.centerY += (cy - handInteraction.centerY) * 0.1;

                // 2. 计算捏合程度 (拇指指尖 vs 食指指尖)
                // Index Tip: 8, Thumb Tip: 4
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // 距离映射: 距离很小(~0.02)是捏合，距离大(~0.2)是张开
                // Map 0.02->0.2 to 0->1
                let spread = (distance - 0.02) * 5; 
                spread = Math.max(0, Math.min(1, spread)); // Clamp 0-1
                
                // 平滑过渡
                handInteraction.spread += (spread - handInteraction.spread) * 0.1;

            } else {
                // 没有检测到手，慢慢恢复默认状态
                handInteraction.active = false;
                handInteraction.spread += (0.5 - handInteraction.spread) * 0.05; // 默认半开状态
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // 启动摄像头
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        
        // 链接预览流
        navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
            videoElement.srcObject = stream;
            previewElement.srcObject = stream;
            cameraUtils.start();
        });


        // ================= 4. 动画循环与交互逻辑 =================
        function animate() {
            requestAnimationFrame(animate);

            if (!originalPositions || originalPositions.length === 0) {
                renderer.render(scene, camera);
                return;
            }

            const positions = geometry.attributes.position.array;
            
            // 手势控制参数
            // spread: 0 (closed) -> 粒子聚集/缩小
            // spread: 1 (open) -> 粒子扩散/正常大小
            
            // 基础扩散因子 (0: 线条清晰, 1: 粒子炸开)
            // 当手张开时(spread=1)，我们希望它是清晰的图(diffusion=0) 或者是放大的？
            // 需求：通过检测单手张合控制粒子群的缩放和扩散
            // 设定：捏合(Closed) = 缩小且聚合；张开(Open) = 放大且扩散 (或者是还原)
            
            // 让我们设定一种酷炫的效果：
            // 手张开大：粒子向外炸开 (Explosion) + 整体变大
            // 手捏合：粒子回归原本的线条 (Form) + 整体正常或缩小
            
            // 修改逻辑以符合直觉：
            // Spread = 1 (张开): 粒子位置加上随机噪点(扩散)
            // Spread = 0 (捏合): 粒子严格回到 originalPositions
            
            const time = Date.now() * 0.001;
            const spreadFactor = handInteraction.spread; // 0 ~ 1
            
            // 放大倍数: 1 + spreadFactor
            const scale = 1 + spreadFactor * 1.5; 
            
            // 扩散噪点幅度: 张开越大，噪点越大
            const noiseAmp = spreadFactor * 50; 

            for (let i = 0; i < positions.length; i += 3) {
                const ox = originalPositions[i];
                const oy = originalPositions[i + 1];
                const oz = originalPositions[i + 2];

                // 目标位置：原始位置 * 缩放
                let tx = ox * scale;
                let ty = oy * scale;
                let tz = oz * scale;

                // 如果手张开，添加噪点 (基于 Perlin 噪音概念的简易版，或者单纯的正弦波)
                if (spreadFactor > 0.1) {
                    tx += (Math.sin(time * 5 + i) * noiseAmp);
                    ty += (Math.cos(time * 3 + i) * noiseAmp);
                    tz += (Math.sin(time * 2 + i) * noiseAmp);
                }

                // 粒子跟随（Lerp）
                positions[i] += (tx - positions[i]) * 0.1;
                positions[i+1] += (ty - positions[i+1]) * 0.1;
                positions[i+2] += (tz - positions[i+2]) * 0.1;
            }
            
            // 响应手部移动，稍微旋转整个粒子群
            if(handInteraction.active) {
                particles.rotation.x += ((-handInteraction.centerY * 0.001) - particles.rotation.x) * 0.05;
                particles.rotation.y += ((handInteraction.centerX * 0.001) - particles.rotation.y) * 0.05;
            }

            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // ================= 5. UI 事件绑定 =================
        
        // 颜色选择器
        document.getElementById('color-picker').addEventListener('input', (e) => {
            material.color.set(e.target.value);
        });

        // 全屏控制
        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

        // 启动
        initThree();

    </script>
</body>
</html>